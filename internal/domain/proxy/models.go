package proxy

import (
	"fmt"
	"net/url"
	"strings"
	"time"

	"github.com/google/uuid"
)

type ProxyConfig struct {
	id            ProxyConfigID
	name          ProxyConfigName
	projectID     uuid.UUID
	serviceName   string
	containerID   string
	hostnames     []string
	targetURL     string
	port          int
	protocol      ProxyProtocol
	pathPrefix    string
	stripPrefix   bool
	tls           *TLSConfig
	middlewares   []MiddlewareConfig
	healthCheck   *HealthCheckConfig
	loadBalancing *LoadBalancingConfig
	status        ProxyStatus
	createdAt     time.Time
	updatedAt     time.Time
}

type ProxyConfigID struct {
	value string
}

func NewProxyConfigID() ProxyConfigID {
	return ProxyConfigID{value: uuid.New().String()}
}

func ProxyConfigIDFromString(s string) (ProxyConfigID, error) {
	if s == "" {
		return ProxyConfigID{}, fmt.Errorf("proxy config ID cannot be empty")
	}
	return ProxyConfigID{value: s}, nil
}

func (id ProxyConfigID) String() string {
	return id.value
}

type ProxyConfigName struct {
	value string
}

func NewProxyConfigName(name string) (ProxyConfigName, error) {
	if name == "" {
		return ProxyConfigName{}, fmt.Errorf("proxy config name cannot be empty")
	}
	if len(name) > 64 {
		return ProxyConfigName{}, fmt.Errorf("proxy config name cannot exceed 64 characters")
	}
	return ProxyConfigName{value: name}, nil
}

func (n ProxyConfigName) String() string {
	return n.value
}

type ProxyProtocol string

const (
	ProxyProtocolHTTP  ProxyProtocol = "http"
	ProxyProtocolHTTPS ProxyProtocol = "https"
	ProxyProtocolTCP   ProxyProtocol = "tcp"
	ProxyProtocolUDP   ProxyProtocol = "udp"
)

type ProxyStatus string

const (
	ProxyStatusCreating ProxyStatus = "creating"
	ProxyStatusActive   ProxyStatus = "active"
	ProxyStatusStopped  ProxyStatus = "stopped"
	ProxyStatusError    ProxyStatus = "error"
)

type TLSConfig struct {
	enabled       bool
	certFile      string
	keyFile       string
	autoGenerated bool
	domains       []string
}

func (t *TLSConfig) Enabled() bool {
	return t.enabled
}

func (t *TLSConfig) CertFile() string {
	return t.certFile
}

func (t *TLSConfig) KeyFile() string {
	return t.keyFile
}

func (t *TLSConfig) AutoGenerated() bool {
	return t.autoGenerated
}

func (t *TLSConfig) Domains() []string {
	return t.domains
}

type MiddlewareConfig struct {
	name   string
	type_  MiddlewareType
	config map[string]interface{}
}

func (m *MiddlewareConfig) Name() string {
	return m.name
}

func (m *MiddlewareConfig) Type() MiddlewareType {
	return m.type_
}

func (m *MiddlewareConfig) Config() map[string]interface{} {
	return m.config
}

type MiddlewareType string

const (
	MiddlewareTypeAuth        MiddlewareType = "auth"
	MiddlewareTypeRateLimit   MiddlewareType = "ratelimit"
	MiddlewareTypeCompression MiddlewareType = "compression"
	MiddlewareTypeCORS        MiddlewareType = "cors"
	MiddlewareTypeHeaders     MiddlewareType = "headers"
	MiddlewareTypeStripPrefix MiddlewareType = "stripprefix"
	MiddlewareTypeRedirect    MiddlewareType = "redirect"
)

type HealthCheckConfig struct {
	enabled  bool
	path     string
	interval time.Duration
	timeout  time.Duration
	retries  int
}

func (h *HealthCheckConfig) Enabled() bool {
	return h.enabled
}

func (h *HealthCheckConfig) Path() string {
	return h.path
}

func (h *HealthCheckConfig) Interval() time.Duration {
	return h.interval
}

func (h *HealthCheckConfig) Timeout() time.Duration {
	return h.timeout
}

func (h *HealthCheckConfig) Retries() int {
	return h.retries
}

type LoadBalancingConfig struct {
	method  LoadBalancingMethod
	servers []string
	sticky  bool
	weights map[string]int
}

type LoadBalancingMethod string

const (
	LoadBalancingMethodRoundRobin LoadBalancingMethod = "roundrobin"
	LoadBalancingMethodLeastConn  LoadBalancingMethod = "leastconn"
	LoadBalancingMethodWeighted   LoadBalancingMethod = "weighted"
)

type TraefikGlobalConfig struct {
	id                   TraefikConfigID
	entryPoints          map[string]EntryPointConfig
	certificateResolvers map[string]CertResolverConfig
	api                  APIConfig
	metrics              MetricsConfig
	log                  LogConfig
	accessLog            AccessLogConfig
	pilot                PilotConfig
	version              string
	createdAt            time.Time
	updatedAt            time.Time
}

type TraefikConfigID struct {
	value string
}

func NewTraefikConfigID() TraefikConfigID {
	return TraefikConfigID{value: uuid.New().String()}
}

func (id TraefikConfigID) String() string {
	return id.value
}

type EntryPointConfig struct {
	address string
	port    int
	tls     *EntryPointTLSConfig
}

type EntryPointTLSConfig struct {
	enabled  bool
	certFile string
	keyFile  string
	options  map[string]interface{}
}

type CertResolverConfig struct {
	acme *ACMEConfig
}

type ACMEConfig struct {
	email         string
	storage       string
	keyType       string
	httpChallenge *HTTPChallengeConfig
	dnsChallenge  *DNSChallengeConfig
}

type HTTPChallengeConfig struct {
	entryPoint string
}

type DNSChallengeConfig struct {
	provider         string
	delayBeforeCheck time.Duration
}

type APIConfig struct {
	enabled   bool
	dashboard bool
	debug     bool
	insecure  bool
}

func (a APIConfig) Enabled() bool {
	return a.enabled
}

func (a APIConfig) Dashboard() bool {
	return a.dashboard
}

func (a APIConfig) Debug() bool {
	return a.debug
}

func (a APIConfig) Insecure() bool {
	return a.insecure
}

type MetricsConfig struct {
	prometheus *PrometheusConfig
}

type PrometheusConfig struct {
	enabled bool
	path    string
	port    int
}

type LogConfig struct {
	level  string
	format string
	path   string
}

type AccessLogConfig struct {
	enabled bool
	path    string
	format  string
}

type PilotConfig struct {
	enabled bool
	token   string
}

func NewProxyConfig(
	name ProxyConfigName,
	projectID uuid.UUID,
	serviceName string,
	containerID string,
	hostnames []string,
	targetURL string,
	port int,
	protocol ProxyProtocol,
) (*ProxyConfig, error) {
	if serviceName == "" {
		return nil, fmt.Errorf("service name cannot be empty")
	}
	if containerID == "" {
		return nil, fmt.Errorf("container ID cannot be empty")
	}
	if len(hostnames) == 0 {
		return nil, fmt.Errorf("at least one hostname must be specified")
	}
	if targetURL == "" {
		return nil, fmt.Errorf("target URL cannot be empty")
	}
	if _, err := url.Parse(targetURL); err != nil {
		return nil, fmt.Errorf("invalid target URL: %w", err)
	}
	if port <= 0 || port > 65535 {
		return nil, fmt.Errorf("invalid port: %d", port)
	}

	now := time.Now()
	return &ProxyConfig{
		id:          NewProxyConfigID(),
		name:        name,
		projectID:   projectID,
		serviceName: serviceName,
		containerID: containerID,
		hostnames:   hostnames,
		targetURL:   targetURL,
		port:        port,
		protocol:    protocol,
		status:      ProxyStatusCreating,
		createdAt:   now,
		updatedAt:   now,
	}, nil
}

func (pc *ProxyConfig) ID() ProxyConfigID {
	return pc.id
}

func (pc *ProxyConfig) Name() ProxyConfigName {
	return pc.name
}

func (pc *ProxyConfig) ProjectID() uuid.UUID {
	return pc.projectID
}

func (pc *ProxyConfig) ServiceName() string {
	return pc.serviceName
}

func (pc *ProxyConfig) ContainerID() string {
	return pc.containerID
}

func (pc *ProxyConfig) Hostnames() []string {
	return pc.hostnames
}

func (pc *ProxyConfig) TargetURL() string {
	return pc.targetURL
}

func (pc *ProxyConfig) Port() int {
	return pc.port
}

func (pc *ProxyConfig) Protocol() ProxyProtocol {
	return pc.protocol
}

func (pc *ProxyConfig) PathPrefix() string {
	return pc.pathPrefix
}

func (pc *ProxyConfig) StripPrefix() bool {
	return pc.stripPrefix
}

func (pc *ProxyConfig) TLS() *TLSConfig {
	return pc.tls
}

func (pc *ProxyConfig) Middlewares() []MiddlewareConfig {
	return pc.middlewares
}

func (pc *ProxyConfig) HealthCheck() *HealthCheckConfig {
	return pc.healthCheck
}

func (pc *ProxyConfig) LoadBalancing() *LoadBalancingConfig {
	return pc.loadBalancing
}

func (pc *ProxyConfig) Status() ProxyStatus {
	return pc.status
}

func (pc *ProxyConfig) CreatedAt() time.Time {
	return pc.createdAt
}

func (pc *ProxyConfig) UpdatedAt() time.Time {
	return pc.updatedAt
}

func (pc *ProxyConfig) SetPathPrefix(prefix string) {
	pc.pathPrefix = prefix
	pc.updatedAt = time.Now()
}

func (pc *ProxyConfig) SetStripPrefix(strip bool) {
	pc.stripPrefix = strip
	pc.updatedAt = time.Now()
}

func (pc *ProxyConfig) SetTLS(tls *TLSConfig) {
	pc.tls = tls
	pc.updatedAt = time.Now()
}

func (pc *ProxyConfig) AddMiddleware(middleware MiddlewareConfig) {
	pc.middlewares = append(pc.middlewares, middleware)
	pc.updatedAt = time.Now()
}

func (pc *ProxyConfig) SetHealthCheck(config *HealthCheckConfig) {
	pc.healthCheck = config
	pc.updatedAt = time.Now()
}

func (pc *ProxyConfig) SetLoadBalancing(config *LoadBalancingConfig) {
	pc.loadBalancing = config
	pc.updatedAt = time.Now()
}

func (pc *ProxyConfig) ChangeStatus(status ProxyStatus) {
	pc.status = status
	pc.updatedAt = time.Now()
}

func (pc *ProxyConfig) UpdateTargetURL(targetURL string) error {
	if _, err := url.Parse(targetURL); err != nil {
		return fmt.Errorf("invalid target URL: %w", err)
	}
	pc.targetURL = targetURL
	pc.updatedAt = time.Now()
	return nil
}

func (pc *ProxyConfig) AddHostname(hostname string) {
	for _, h := range pc.hostnames {
		if h == hostname {
			return
		}
	}
	pc.hostnames = append(pc.hostnames, hostname)
	pc.updatedAt = time.Now()
}

func (pc *ProxyConfig) RemoveHostname(hostname string) {
	for i, h := range pc.hostnames {
		if h == hostname {
			pc.hostnames = append(pc.hostnames[:i], pc.hostnames[i+1:]...)
			break
		}
	}
	pc.updatedAt = time.Now()
}

func (pc *ProxyConfig) GetRouterName() string {
	return fmt.Sprintf("mikrocloud-%s-%s", pc.projectID.String()[:8], pc.serviceName)
}

func (pc *ProxyConfig) GetServiceName() string {
	return fmt.Sprintf("mikrocloud-service-%s-%s", pc.projectID.String()[:8], pc.serviceName)
}

func (pc *ProxyConfig) GetRuleHost() string {
	if len(pc.hostnames) == 0 {
		return ""
	}
	hosts := make([]string, len(pc.hostnames))
	for i, h := range pc.hostnames {
		hosts[i] = fmt.Sprintf("`%s`", h)
	}
	return fmt.Sprintf("Host(%s)", strings.Join(hosts, ","))
}

func NewTraefikGlobalConfig() *TraefikGlobalConfig {
	now := time.Now()
	return &TraefikGlobalConfig{
		id: NewTraefikConfigID(),
		entryPoints: map[string]EntryPointConfig{
			"web": {
				address: ":80",
				port:    80,
			},
			"websecure": {
				address: ":443",
				port:    443,
				tls: &EntryPointTLSConfig{
					enabled: true,
				},
			},
		},
		api: APIConfig{
			enabled:   true,
			dashboard: true,
			debug:     false,
			insecure:  false,
		},
		log: LogConfig{
			level:  "INFO",
			format: "json",
		},
		accessLog: AccessLogConfig{
			enabled: true,
			format:  "json",
		},
		version:   "v3.0",
		createdAt: now,
		updatedAt: now,
	}
}

func (tgc *TraefikGlobalConfig) ID() TraefikConfigID {
	return tgc.id
}

func (tgc *TraefikGlobalConfig) EntryPoints() map[string]EntryPointConfig {
	return tgc.entryPoints
}

func (tgc *TraefikGlobalConfig) API() APIConfig {
	return tgc.api
}

func (tgc *TraefikGlobalConfig) SetMetrics(config MetricsConfig) {
	tgc.metrics = config
	tgc.updatedAt = time.Now()
}

func (tgc *TraefikGlobalConfig) CreatedAt() time.Time {
	return tgc.createdAt
}

func (tgc *TraefikGlobalConfig) UpdatedAt() time.Time {
	return tgc.updatedAt
}

func (tgc *TraefikGlobalConfig) AddCertResolver(name string, resolver CertResolverConfig) {
	if tgc.certificateResolvers == nil {
		tgc.certificateResolvers = make(map[string]CertResolverConfig)
	}
	tgc.certificateResolvers[name] = resolver
	tgc.updatedAt = time.Now()
}

func ReconstructProxyConfig(
	id ProxyConfigID,
	name ProxyConfigName,
	projectID uuid.UUID,
	serviceName, containerID string,
	hostnames []string,
	targetURL string,
	port int,
	protocol ProxyProtocol,
	pathPrefix string,
	stripPrefix bool,
	tls *TLSConfig,
	middlewares []MiddlewareConfig,
	healthCheck *HealthCheckConfig,
	loadBalancing *LoadBalancingConfig,
	status ProxyStatus,
	createdAt, updatedAt time.Time,
) *ProxyConfig {
	return &ProxyConfig{
		id:            id,
		name:          name,
		projectID:     projectID,
		serviceName:   serviceName,
		containerID:   containerID,
		hostnames:     hostnames,
		targetURL:     targetURL,
		port:          port,
		protocol:      protocol,
		pathPrefix:    pathPrefix,
		stripPrefix:   stripPrefix,
		tls:           tls,
		middlewares:   middlewares,
		healthCheck:   healthCheck,
		loadBalancing: loadBalancing,
		status:        status,
		createdAt:     createdAt,
		updatedAt:     updatedAt,
	}
}
