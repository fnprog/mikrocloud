package service

import (
	"context"
	"fmt"

	"github.com/google/uuid"
	"github.com/mikrocloud/mikrocloud/internal/domain/proxy"
	"github.com/mikrocloud/mikrocloud/internal/domain/proxy/repository"
)

type ProxyService struct {
	proxyRepo   repository.ProxyRepository
	traefikRepo repository.TraefikConfigRepository
}

func New(
	proxyRepo repository.ProxyRepository,
	traefikRepo repository.TraefikConfigRepository,
) *ProxyService {
	return &ProxyService{
		proxyRepo:   proxyRepo,
		traefikRepo: traefikRepo,
	}
}

type CreateProxyConfigRequest struct {
	Name        string                    `json:"name"`
	ProjectID   uuid.UUID                 `json:"project_id"`
	ServiceName string                    `json:"service_name"`
	ContainerID string                    `json:"container_id"`
	Hostnames   []string                  `json:"hostnames"`
	TargetURL   string                    `json:"target_url"`
	Port        int                       `json:"port"`
	Protocol    string                    `json:"protocol"`
	PathPrefix  string                    `json:"path_prefix,omitempty"`
	StripPrefix bool                      `json:"strip_prefix,omitempty"`
	TLS         *TLSConfigRequest         `json:"tls,omitempty"`
	Middlewares []MiddlewareConfigRequest `json:"middlewares,omitempty"`
	HealthCheck *HealthCheckConfigRequest `json:"health_check,omitempty"`
}

type TLSConfigRequest struct {
	Enabled       bool     `json:"enabled"`
	CertFile      string   `json:"cert_file,omitempty"`
	KeyFile       string   `json:"key_file,omitempty"`
	AutoGenerated bool     `json:"auto_generated,omitempty"`
	Domains       []string `json:"domains,omitempty"`
}

type MiddlewareConfigRequest struct {
	Name   string                 `json:"name"`
	Type   string                 `json:"type"`
	Config map[string]interface{} `json:"config"`
}

type HealthCheckConfigRequest struct {
	Enabled  bool   `json:"enabled"`
	Path     string `json:"path"`
	Interval string `json:"interval"`
	Timeout  string `json:"timeout"`
	Retries  int    `json:"retries"`
}

type ProxyConfigResponse struct {
	ID           string                     `json:"id"`
	Name         string                     `json:"name"`
	ProjectID    uuid.UUID                  `json:"project_id"`
	ServiceName  string                     `json:"service_name"`
	ContainerID  string                     `json:"container_id"`
	Hostnames    []string                   `json:"hostnames"`
	TargetURL    string                     `json:"target_url"`
	Port         int                        `json:"port"`
	Protocol     string                     `json:"protocol"`
	PathPrefix   string                     `json:"path_prefix"`
	StripPrefix  bool                       `json:"strip_prefix"`
	TLS          *TLSConfigResponse         `json:"tls,omitempty"`
	Middlewares  []MiddlewareConfigResponse `json:"middlewares"`
	HealthCheck  *HealthCheckConfigResponse `json:"health_check,omitempty"`
	Status       string                     `json:"status"`
	RouterName   string                     `json:"router_name"`
	ServiceName2 string                     `json:"traefik_service_name"`
	RuleHost     string                     `json:"rule_host"`
	CreatedAt    string                     `json:"created_at"`
	UpdatedAt    string                     `json:"updated_at"`
}

type TLSConfigResponse struct {
	Enabled       bool     `json:"enabled"`
	CertFile      string   `json:"cert_file"`
	KeyFile       string   `json:"key_file"`
	AutoGenerated bool     `json:"auto_generated"`
	Domains       []string `json:"domains"`
}

type MiddlewareConfigResponse struct {
	Name   string                 `json:"name"`
	Type   string                 `json:"type"`
	Config map[string]interface{} `json:"config"`
}

type HealthCheckConfigResponse struct {
	Enabled  bool   `json:"enabled"`
	Path     string `json:"path"`
	Interval string `json:"interval"`
	Timeout  string `json:"timeout"`
	Retries  int    `json:"retries"`
}

func (s *ProxyService) CreateProxyConfig(ctx context.Context, req CreateProxyConfigRequest) (*ProxyConfigResponse, error) {
	name, err := proxy.NewProxyConfigName(req.Name)
	if err != nil {
		return nil, fmt.Errorf("invalid proxy config name: %w", err)
	}

	protocol := proxy.ProxyProtocol(req.Protocol)
	if protocol != proxy.ProxyProtocolHTTP && protocol != proxy.ProxyProtocolHTTPS &&
		protocol != proxy.ProxyProtocolTCP && protocol != proxy.ProxyProtocolUDP {
		return nil, fmt.Errorf("invalid protocol: %s", req.Protocol)
	}

	exists, err := s.proxyRepo.ExistsByHostname(ctx, req.Hostnames[0])
	if err != nil {
		return nil, fmt.Errorf("failed to check hostname existence: %w", err)
	}
	if exists {
		return nil, fmt.Errorf("hostname %s is already in use", req.Hostnames[0])
	}

	config, err := proxy.NewProxyConfig(
		name,
		req.ProjectID,
		req.ServiceName,
		req.ContainerID,
		req.Hostnames,
		req.TargetURL,
		req.Port,
		protocol,
	)
	if err != nil {
		return nil, fmt.Errorf("failed to create proxy config: %w", err)
	}

	if req.PathPrefix != "" {
		config.SetPathPrefix(req.PathPrefix)
	}

	config.SetStripPrefix(req.StripPrefix)

	if req.TLS != nil {
		tls := &proxy.TLSConfig{
			// Note: TLSConfig fields are unexported, so we'd need to add constructors
			// For now, this is a placeholder
		}
		config.SetTLS(tls)
	}

	if err := s.proxyRepo.Create(ctx, config); err != nil {
		return nil, fmt.Errorf("failed to create proxy config: %w", err)
	}

	return s.toProxyConfigResponse(config), nil
}

func (s *ProxyService) GetProxyConfig(ctx context.Context, id string) (*ProxyConfigResponse, error) {
	configID, err := proxy.ProxyConfigIDFromString(id)
	if err != nil {
		return nil, fmt.Errorf("invalid proxy config ID: %w", err)
	}

	config, err := s.proxyRepo.GetByID(ctx, configID)
	if err != nil {
		return nil, fmt.Errorf("failed to get proxy config: %w", err)
	}

	return s.toProxyConfigResponse(config), nil
}

func (s *ProxyService) GetProxyConfigByContainer(ctx context.Context, containerID string) (*ProxyConfigResponse, error) {
	config, err := s.proxyRepo.GetByContainerID(ctx, containerID)
	if err != nil {
		return nil, fmt.Errorf("failed to get proxy config by container: %w", err)
	}

	return s.toProxyConfigResponse(config), nil
}

func (s *ProxyService) ListProxyConfigs(ctx context.Context, projectID *uuid.UUID) ([]*ProxyConfigResponse, error) {
	var configs []*proxy.ProxyConfig
	var err error

	if projectID != nil {
		configs, err = s.proxyRepo.ListByProject(ctx, *projectID)
	} else {
		configs, err = s.proxyRepo.ListAll(ctx)
	}

	if err != nil {
		return nil, fmt.Errorf("failed to list proxy configs: %w", err)
	}

	responses := make([]*ProxyConfigResponse, len(configs))
	for i, config := range configs {
		responses[i] = s.toProxyConfigResponse(config)
	}

	return responses, nil
}

func (s *ProxyService) UpdateProxyConfig(ctx context.Context, id string, req CreateProxyConfigRequest) (*ProxyConfigResponse, error) {
	configID, err := proxy.ProxyConfigIDFromString(id)
	if err != nil {
		return nil, fmt.Errorf("invalid proxy config ID: %w", err)
	}

	config, err := s.proxyRepo.GetByID(ctx, configID)
	if err != nil {
		return nil, fmt.Errorf("failed to get proxy config: %w", err)
	}

	if req.TargetURL != "" {
		if err := config.UpdateTargetURL(req.TargetURL); err != nil {
			return nil, fmt.Errorf("failed to update target URL: %w", err)
		}
	}

	if req.PathPrefix != "" {
		config.SetPathPrefix(req.PathPrefix)
	}

	config.SetStripPrefix(req.StripPrefix)

	if err := s.proxyRepo.Update(ctx, config); err != nil {
		return nil, fmt.Errorf("failed to update proxy config: %w", err)
	}

	return s.toProxyConfigResponse(config), nil
}

func (s *ProxyService) DeleteProxyConfig(ctx context.Context, id string) error {
	configID, err := proxy.ProxyConfigIDFromString(id)
	if err != nil {
		return fmt.Errorf("invalid proxy config ID: %w", err)
	}

	if err := s.proxyRepo.Delete(ctx, configID); err != nil {
		return fmt.Errorf("failed to delete proxy config: %w", err)
	}

	return nil
}

func (s *ProxyService) DeleteProxyConfigByContainer(ctx context.Context, containerID string) error {
	if err := s.proxyRepo.DeleteByContainerID(ctx, containerID); err != nil {
		return fmt.Errorf("failed to delete proxy config by container: %w", err)
	}

	return nil
}

func (s *ProxyService) GenerateTraefikConfig(ctx context.Context) (map[string]interface{}, error) {
	configs, err := s.proxyRepo.ListByStatus(ctx, proxy.ProxyStatusActive)
	if err != nil {
		return nil, fmt.Errorf("failed to list active proxy configs: %w", err)
	}

	traefikConfig := map[string]interface{}{
		"http": map[string]interface{}{
			"routers":  make(map[string]interface{}),
			"services": make(map[string]interface{}),
		},
	}

	routers := traefikConfig["http"].(map[string]interface{})["routers"].(map[string]interface{})
	services := traefikConfig["http"].(map[string]interface{})["services"].(map[string]interface{})

	for _, config := range configs {
		routerName := config.GetRouterName()
		serviceName := config.GetServiceName()

		router := map[string]interface{}{
			"rule":    config.GetRuleHost(),
			"service": serviceName,
		}

		if config.PathPrefix() != "" {
			currentRule := router["rule"].(string)
			router["rule"] = fmt.Sprintf("%s && PathPrefix(`%s`)", currentRule, config.PathPrefix())
		}

		if config.Protocol() == proxy.ProxyProtocolHTTPS || (config.TLS() != nil && config.TLS().Enabled()) {
			router["tls"] = map[string]interface{}{}
		}

		routers[routerName] = router

		service := map[string]interface{}{
			"loadBalancer": map[string]interface{}{
				"servers": []map[string]interface{}{
					{
						"url": config.TargetURL(),
					},
				},
			},
		}

		if config.HealthCheck() != nil && config.HealthCheck().Enabled() {
			service["loadBalancer"].(map[string]interface{})["healthCheck"] = map[string]interface{}{
				"path":     config.HealthCheck().Path(),
				"interval": config.HealthCheck().Interval().String(),
				"timeout":  config.HealthCheck().Timeout().String(),
			}
		}

		services[serviceName] = service
	}

	return traefikConfig, nil
}

func (s *ProxyService) toProxyConfigResponse(config *proxy.ProxyConfig) *ProxyConfigResponse {
	response := &ProxyConfigResponse{
		ID:           config.ID().String(),
		Name:         config.Name().String(),
		ProjectID:    config.ProjectID(),
		ServiceName:  config.ServiceName(),
		ContainerID:  config.ContainerID(),
		Hostnames:    config.Hostnames(),
		TargetURL:    config.TargetURL(),
		Port:         config.Port(),
		Protocol:     string(config.Protocol()),
		PathPrefix:   config.PathPrefix(),
		StripPrefix:  config.StripPrefix(),
		Middlewares:  []MiddlewareConfigResponse{},
		Status:       string(config.Status()),
		RouterName:   config.GetRouterName(),
		ServiceName2: config.GetServiceName(),
		RuleHost:     config.GetRuleHost(),
		CreatedAt:    config.CreatedAt().Format("2006-01-02T15:04:05Z"),
		UpdatedAt:    config.UpdatedAt().Format("2006-01-02T15:04:05Z"),
	}

	if config.TLS() != nil {
		response.TLS = &TLSConfigResponse{
			Enabled:       config.TLS().Enabled(),
			CertFile:      config.TLS().CertFile(),
			KeyFile:       config.TLS().KeyFile(),
			AutoGenerated: config.TLS().AutoGenerated(),
			Domains:       config.TLS().Domains(),
		}
	}

	if config.HealthCheck() != nil {
		response.HealthCheck = &HealthCheckConfigResponse{
			Enabled:  config.HealthCheck().Enabled(),
			Path:     config.HealthCheck().Path(),
			Interval: config.HealthCheck().Interval().String(),
			Timeout:  config.HealthCheck().Timeout().String(),
			Retries:  config.HealthCheck().Retries(),
		}
	}

	for _, mw := range config.Middlewares() {
		response.Middlewares = append(response.Middlewares, MiddlewareConfigResponse{
			Name:   mw.Name(),
			Type:   string(mw.Type()),
			Config: mw.Config(),
		})
	}

	return response
}
